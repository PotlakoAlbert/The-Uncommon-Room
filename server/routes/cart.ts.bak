import { Router } from "express";
import { db } from "../db";
import { 
  users, products, carts, cartItems,
  inventory,
  type Cart, type CartItem
} from "@shared/schema";
import { eq, and, sql } from "drizzle-orm";
import { z } from "zod";
import { authenticateToken as auth, type AuthRequest } from "../middleware/auth";
import { BadRequestError, NotFoundError } from "../middleware/error";

const router = Router();

// Schema validation
const cartItemSchema = z.object({
  productId: z.number(),
  quantity: z.number().min(1),
  customNotes: z.string().optional(),
});

const updateCartItemSchema = z.object({
  quantity: z.number().min(1),
  customNotes: z.string().optional(),
});

// Get cart items with product details
router.get("/", auth, async (req: AuthRequest, res) => {
  try {
    const cart = await db.query.carts.findFirst({
      where: eq(carts.userId, req.user!.id),
      with: {
        items: {
          with: {
            product: true,
          },
        },
      },
    });

    // If no cart, return empty array for consistent response
    if (!cart) {
      return res.json([]);
    }

    res.json(cart.items);
  } catch (error) {
    console.error("Error fetching cart:", error);
    throw error; // Let error middleware handle it
  }
});

// Add item to cart with stock validation
router.post("/", auth, async (req: AuthRequest, res) => {
  try {
    const input = cartItemSchema.parse(req.body);

    // Check product exists and is in stock
    const product = await db.query.products.findFirst({
      where: eq(products.prodId, input.productId),
      with: {
        inventory: true,
      },
    });

    if (!product) {
      throw new NotFoundError("Product not found");
    }

    // Validate stock
    if (!product.inventory?.[0] || product.inventory[0].quantity < input.quantity) {
      throw new BadRequestError("Not enough stock available");
    }

    // Get or create cart
    let cart: Cart | undefined = await db.query.carts.findFirst({
      where: eq(carts.userId, req.user!.id),
    });

    if (!cart) {
      [cart] = await db
        .insert(carts)
        .values({ userId: req.user!.id })
        .returning();
    }

    // Check existing item in cart
    const existingItem = await db.query.cartItems.findFirst({
      where: and(
        eq(cartItems.cartId, cart.id),
        eq(cartItems.productId, input.productId)
      ),
    });

    let updatedItem: CartItem;

    // Run in transaction to ensure stock and cart updates are atomic
    await db.transaction(async (tx) => {
      if (existingItem) {
        // Validate combined quantity
        const totalQuantity = existingItem.quantity + input.quantity;
        if (!product.inventory?.[0] || product.inventory[0].quantity < totalQuantity) {
          throw new BadRequestError("Not enough stock available for total quantity");
        }

        // Update quantity
        const [updated] = await tx.update(cartItems)
          .set({
            quantity: existingItem.quantity + input.quantity,
            customNotes: input.customNotes,
          })
          .where(eq(cartItems.id, existingItem.id))
          .returning();

        updatedItem = updated;
      } else {
        // Add new item
        const [newItem] = await tx.insert(cartItems)
          .values({
            cartId: cart.id,
            productId: input.productId,
            quantity: input.quantity,
            customNotes: input.customNotes,
          })
          .returning();

        updatedItem = newItem;
      }

      // Lock inventory for update
      const [currentInventory] = await tx
        .select()
        .from(inventory)
        .where(eq(inventory.productId, input.productId))
        .forUpdate();

      if (!currentInventory || currentInventory.quantity < input.quantity) {
        throw new BadRequestError("Stock was depleted while adding to cart");
      }
    });

    // Get cart with items
    const updatedCart = await db.query.cartItems.findMany({
      where: eq(cartItems.cartId, cart.id),
      with: {
        product: true,
      },
    });

    res.json(updatedCart);
  } catch (error) {
    console.error("Error adding to cart:", error);
    throw error; // Let error middleware handle it
  }
});

// Update cart item quantity
router.put("/item/:id", auth, async (req: AuthRequest, res) => {
  try {
    const input = updateCartItemSchema.parse(req.body);
    const itemId = parseInt(req.params.id);

    // Get user's cart
    const cart = await db.query.carts.findFirst({
      where: eq(carts.userId, req.user!.id),
    });

    if (!cart) {
      return res.status(404).json({ message: "Cart not found" });
    }

    await db
      .update(cartItems)
      .set({ quantity })
      .where(
        and(eq(cartItems.id, itemId), eq(cartItems.cartId, cart.id))
      );

    const updatedCart = await db.query.cartItems.findMany({
      where: eq(cartItems.cartId, cart.id),
      with: {
        product: true,
      },
    });

    res.json(updatedCart);
  } catch (error) {
    console.error(error);
    res.status(400).json({ message: "Invalid input" });
  }
});

// Remove item from cart
router.delete("/item/:id", auth, async (req: AuthRequest, res) => {
  try {
    const itemId = parseInt(req.params.id);

    const cart = await db.query.carts.findFirst({
      where: eq(carts.userId, req.user!.id),
    });

    if (!cart) {
      return res.status(404).json({ message: "Cart not found" });
    }

    await db
      .delete(cartItems)
      .where(
        and(eq(cartItems.id, itemId), eq(cartItems.cartId, cart.id))
      );

    const updatedCart = await db.query.cartItems.findMany({
      where: eq(cartItems.cartId, cart.id),
      with: {
        product: true,
      },
    });

    res.json(updatedCart);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Server error" });
  }
});

export default router;
